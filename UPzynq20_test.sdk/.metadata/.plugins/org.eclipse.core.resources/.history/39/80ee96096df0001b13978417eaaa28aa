/*
 * control_transistor_keys.c
 *
 *  Created on: 29 июл. 2021 г.
 *      Author: stud
 */


#include "control_transistor_keys.h"
#include "xplatform_info.h"
#include "xparameters.h"

u32 min_time_error_group_0 = 0;
u32 min_time_error_group_1 = 0;
u32 min_time_error_group_2 = 0;

u32 acknowledge_error_group_0 = 0;
u32 acknowledge_error_group_1 = 0;
u32 acknowledge_error_group_2 = 0;

u32 current_error_group_0 = 0;
u32 current_error_group_1 = 0;
u32 current_error_group_2 = 0;

u32 breaking_enable = 0;

u32 mask_ch_group_0 = 0;
u32 mask_ch_group_1 = 0;
u32 mask_ch_group_2 = 0;



u32 get_current_value_adc_channel(u32 channel){
	return Xil_In32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR + channel*4);
}

void set_setpoint_value_adc_channel(u32 channel, u32 data){
	Xil_Out32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR + channel*4, data);
}

void get_current_value_adc_table(){
	for (u32 i = 0; i < 16; i++) {
//		adc_channel[i] = ((get_current_value_adc_channel(i)-2047)*ADC_UNIT/load_resistances[i])*sensor_coefficients[i]/MULTIPLIER;

		adc_channel[i] = get_current_value_adc_channel(i);
	}
}

u32 get_value_adc_channel(u32 channel){
	return adc_channel[channel];
}

u32 get_value_errors_adc_table(){
	Xil_Out32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR + 12, 16);
	return Xil_In32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR + 64);
}

void set_setpoint_value_adc_table(){
	Xil_Out32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR, 0x00000001);
	for (int i = 0; i < 16; i++) {
		Xil_Out32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR + 4, i);
		Xil_Out32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR + 8, setpoint_channel_down[i]);
	}
	for (int i = 0; i < 16; i++) {
			Xil_Out32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR + 4, i+16);
			Xil_Out32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR + 8, setpoint_channel_up[i]);
		}
	Xil_Out32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR, 0x00000000);
}

void set_reset_error_adc_table(){
	Xil_Out32(XPAR_IP_AXI_ADC_0_S00_AXI_BASEADDR + 16, 0x00000001);
	for (int i = 0; i < 100; i++){
		//
	}
}

void get_value_errors_negative_positive_adc_table(){
	negative_errors = get_value_errors_adc_table();						// подготовка регистра ошибок АЦП
	positive_errors = negative_errors/65356;
	generalized_errors = negative_errors | positive_errors;
}

u32 get_value_errors_negative_positive_adc(int value){
	if (value == 0) {
		return negative_errors;
	}
	if (value == 1) {
		return positive_errors;
	}
	if (value == 2) {
		return generalized_errors;
	}
}



